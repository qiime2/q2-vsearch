
import tempfile
import subprocess

import biom
from q2_types.feature_data import DNAFASTAFormat

def run_command(cmd, verbose=True):
    print("Running external command line application. This may print "
          "messages to stdout and/or stderr.")
    print("The command being run is below. This command cannot "
          "be manually re-run as it will depend on temporary files that "
          "no longer exist.")
    print("\nCommand:", end=' ')
    print(" ".join(cmd), end='\n\n')
    subprocess.run(cmd, check=True)

def _collapse_f_from_uc(uc):
    id_to_centroid = {}
    for line in uc:
        line = line.strip()
        if line.startswith(b'#'):
            continue
        else:
            fields = line.split(b'\t')
            if fields[0] == b'S':
                id_to_centroid[fields[8].decode('utf-8')] = \
                    fields[8].decode('utf-8')
            elif fields[0] == b'H':
                id_to_centroid[fields[8].decode('utf-8')] = \
                    fields[9].decode('utf-8')
            else:
                pass

    def collapse_f(id_, x):
        try:
            return id_to_centroid[id_]
        except KeyError:
            raise KeyError('ID %s is not present in clustering results. This '
                           'can happen when table and representative '
                           'sequences were not generated by the same process.'
                           % id_)

    return collapse_f

def cluster_features(sequences: DNAFASTAFormat, table: biom.Table,
                     id: float) -> (biom.Table, DNAFASTAFormat):
    sequences_fp = str(sequences)
    clustered_sequences = DNAFASTAFormat()
    with tempfile.NamedTemporaryFile() as out_uc:
        cmd = ['vsearch', '--cluster_fast', sequences_fp, '--id', str(id),
               '--centroids', str(clustered_sequences), '--uc',
               out_uc.name, '--qmask', 'none']
        run_command(cmd)
        out_uc.seek(0)
        collapse_f = _collapse_f_from_uc(out_uc)

    table = table.collapse(collapse_f, norm=False, min_group_size=1,
                           axis='observation')

    return table, clustered_sequences
